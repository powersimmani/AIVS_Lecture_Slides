<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ridge Regression (L2 Regularization) - Complete Guide</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Aptos, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .main-container {
            max-width: 960px;
            margin: 0 auto;
        }
        
        .section {
            background: white;
            padding: 35px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 28px;
            font-weight: 700;
            color: #1E64C8;
            margin-bottom: 25px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }
        
        .section-title {
            font-size: 24px;
            font-weight: 700;
            color: #1E64C8;
            margin-bottom: 25px;
            text-align: center;
            border-bottom: 4px solid #1E64C8;
            padding-bottom: 12px;
        }
        
        /* Overview Styles */
        .content-layout {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .problem-solution-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
        }
        
        .problem-box {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            border-radius: 12px;
            padding: 22px 24px;
            color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }
        
        .problem-label {
            font-size: 17px;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        .problem-text {
            font-size: 18px;
            font-weight: 500;
            line-height: 1.5;
        }
        
        .arrow-divider {
            font-size: 36px;
            color: #1E64C8;
            font-weight: bold;
        }
        
        .solution-box {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            border-radius: 12px;
            padding: 22px 24px;
            color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }
        
        .solution-label {
            font-size: 17px;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        .solution-text {
            font-size: 18px;
            font-weight: 500;
            line-height: 1.5;
        }
        
        .cost-function-box {
            background: white;
            border: 3px solid #1E64C8;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(30, 100, 200, 0.1);
        }
        
        .cost-label {
            font-size: 17px;
            color: #666;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .cost-formula {
            font-size: 24px;
            color: #1E64C8;
            font-weight: 700;
            font-style: italic;
            letter-spacing: 1px;
        }
        
        .cost-description {
            font-size: 17px;
            color: #666;
            margin-top: 12px;
            font-weight: 500;
        }
        
        .features-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .feature-card {
            background: white;
            border: 2px solid #1E64C8;
            border-left: 6px solid #1E64C8;
            border-radius: 10px;
            padding: 18px 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            transition: all 0.3s;
        }
        
        .feature-card:hover {
            background: #f8fbff;
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(30, 100, 200, 0.2);
        }
        
        .feature-title {
            font-size: 18px;
            font-weight: 700;
            color: #1E64C8;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .feature-icon {
            font-size: 22px;
        }
        
        .feature-desc {
            font-size: 16px;
            color: #555;
            line-height: 1.5;
        }
        
        .lambda-card {
            grid-column: span 2;
            background: #fff8e6;
            border-color: #ffc107;
            border-left-color: #ffc107;
        }
        
        .lambda-card .feature-title {
            color: #f57c00;
        }
        
        .benefit-card {
            grid-column: span 2;
            background: #e8f5e9;
            border-color: #28a745;
            border-left-color: #28a745;
        }
        
        .benefit-card .feature-title {
            color: #28a745;
        }
        
        /* 2D Visualization Styles */
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .comparison-card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            border: 2px solid #e9ecef;
        }
        
        .comparison-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 20px;
        }
        
        .l2-highlight {
            color: #1E64C8;
        }
        
        .l1-highlight {
            color: #dc3545;
        }
        
        .lambda-slider-section {
            background: white;
            border: 3px solid #1E64C8;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .slider-container {
            margin: 25px 0;
        }
        
        .slider-label {
            font-size: 18px;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
        }
        
        .lambda-value {
            color: #1E64C8;
            font-size: 24px;
            font-weight: 700;
        }
        
        input[type="range"] {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #1E64C8;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(30, 100, 200, 0.4);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #1E64C8;
            cursor: pointer;
        }
        
        .coefficients-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 25px;
        }
        
        .coeff-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-left: 5px solid #1E64C8;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .coeff-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .coeff-label {
            font-size: 15px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .coeff-value {
            font-size: 28px;
            font-weight: 700;
            color: #1E64C8;
        }
        
        .explanation-text {
            font-size: 17px;
            line-height: 1.8;
            color: #333;
            margin-bottom: 18px;
        }
        
        .highlight-box {
            background: #e8f5e9;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        
        .highlight-box-yellow {
            background: #fff8e6;
            border-left: 5px solid #ffc107;
        }
        
        .formula-box {
            background: #f8f9fa;
            border: 3px solid #1E64C8;
            border-radius: 10px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
        }
        
        .formula-text {
            font-size: 20px;
            font-weight: 700;
            color: #1E64C8;
            font-family: 'Courier New', monospace;
        }
        
        canvas {
            display: block;
            margin: 20px auto;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            background: white;
        }
        
        .geometric-explanation {
            background: white;
            border: 3px solid #28a745;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .multicollinearity-box {
            background: white;
            border: 3px solid #ffc107;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        /* 3D Visualization Styles */
        .viz-container-3d {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .canvas-wrapper {
            border: 2px solid #1E64C8;
            border-radius: 10px;
            overflow: hidden;
            background: #f8f9fa;
        }
        
        .canvas-header {
            background: #1E64C8;
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 600;
            font-size: 16px;
        }
        
        #canvas-ols, #canvas-ridge {
            display: block;
            width: 100%;
            height: 350px;
        }
        
        .controls {
            background: white;
            border: 2px solid #1E64C8;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .control-label {
            min-width: 150px;
            font-weight: 600;
            color: #333;
        }
        
        .control-value {
            min-width: 50px;
            font-weight: 700;
            color: #1E64C8;
        }
        
        input[type="range"].control-slider {
            flex: 1;
        }
        
        .viz-subtitle {
            font-size: 16px;
            color: #666;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Overview Section -->
        <div class="section">
            <div class="title">Ridge Regression (L2 Regularization)</div>
            
            <div class="content-layout">
                <div class="problem-solution-row">
                    <div class="problem-box">
                        <div class="problem-label">PROBLEM</div>
                        <div class="problem-text">Large coefficients<br>lead to overfitting</div>
                    </div>
                    
                    <div class="arrow-divider">‚Üí</div>
                    
                    <div class="solution-box">
                        <div class="solution-label">SOLUTION</div>
                        <div class="solution-text">Add penalty term<br>for large coefficients</div>
                    </div>
                </div>
                
                <div class="cost-function-box">
                    <div class="cost-label">Cost Function:</div>
                    <div class="cost-formula">RSS + Œª‚àëŒ≤·µ¢¬≤</div>
                    <div class="cost-description">(L2 Penalty)</div>
                </div>
                
                <div class="features-grid">
                    <div class="feature-card">
                        <div class="feature-title">
                            <span class="feature-icon">üìâ</span>
                            Coefficient Shrinkage
                        </div>
                        <div class="feature-desc">
                            Shrinks coefficients toward zero (but not exactly zero)
                        </div>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-title">
                            <span class="feature-icon">‚öôÔ∏è</span>
                            Hyperparameter Œª
                        </div>
                        <div class="feature-desc">
                            Controls regularization strength
                        </div>
                    </div>
                    
                    <div class="feature-card lambda-card">
                        <div class="feature-title">
                            <span class="feature-icon">üìä</span>
                            Effect of Œª
                        </div>
                        <div class="feature-desc">
                            Larger Œª ‚Üí more regularization, simpler model
                        </div>
                    </div>
                    
                    <div class="feature-card benefit-card">
                        <div class="feature-title">
                            <span class="feature-icon">‚úì</span>
                            Key Benefit
                        </div>
                        <div class="feature-desc">
                            Helps with multicollinearity problem
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 2D Visualization Section -->
        <div class="section">
            <div class="section-title">üéØ 2D Visual Understanding</div>
            
            <!-- L1 vs L2 Comparison -->
            <div class="comparison-grid">
                <div class="comparison-card">
                    <div class="comparison-title l2-highlight">L2 (Ridge) üîµ</div>
                    <canvas id="l2Canvas" width="280" height="280"></canvas>
                    <p style="margin-top: 18px; font-size: 15px; color: #666; line-height: 1.6;">
                        <strong style="color: #1E64C8;">Circle shape</strong><br>
                        w‚ÇÄ¬≤ + w‚ÇÅ¬≤ = constant<br>
                        Gradually shrinks coefficients
                    </p>
                </div>
                
                <div class="comparison-card">
                    <div class="comparison-title l1-highlight">L1 (Lasso) üî¥</div>
                    <canvas id="l1Canvas" width="280" height="280"></canvas>
                    <p style="margin-top: 18px; font-size: 15px; color: #666; line-height: 1.6;">
                        <strong style="color: #dc3545;">Diamond shape</strong><br>
                        |w‚ÇÄ| + |w‚ÇÅ| = constant<br>
                        Can make coefficients exactly zero
                    </p>
                </div>
            </div>
        </div>
        
        <!-- Interactive Lambda Slider -->
        <div class="section">
            <div class="lambda-slider-section">
                <h3 style="text-align: center; color: #1E64C8; margin-bottom: 25px; font-size: 22px;">
                    üéöÔ∏è Interactive: Effect of Œª on Coefficients
                </h3>
                
                <div class="slider-container">
                    <div class="slider-label">
                        Œª (Lambda) = <span class="lambda-value" id="lambdaValue">0.0</span>
                    </div>
                    <input type="range" id="lambdaSlider" min="0" max="100" value="0" step="1">
                    <p style="font-size: 14px; color: #666; margin-top: 10px;">
                        üí° Move the slider to change Œª value. As Œª increases, coefficients shrink toward zero!
                    </p>
                </div>
                
                <div class="coefficients-display">
                    <div class="coeff-card">
                        <div class="coeff-label">Œ≤‚ÇÅ (original: 5.00)</div>
                        <div class="coeff-value" id="coeff1">5.00</div>
                    </div>
                    <div class="coeff-card">
                        <div class="coeff-label">Œ≤‚ÇÇ (original: 3.00)</div>
                        <div class="coeff-value" id="coeff2">3.00</div>
                    </div>
                    <div class="coeff-card">
                        <div class="coeff-label">Œ≤‚ÇÉ (original: 4.00)</div>
                        <div class="coeff-value" id="coeff3">4.00</div>
                    </div>
                </div>
                
                <canvas id="coeffChart" width="860" height="350"></canvas>
            </div>
        </div>
        
        <!-- Geometric Explanation -->
        <div class="section">
            <div class="geometric-explanation">
                <h3 style="text-align: center; color: #28a745; margin-bottom: 25px; font-size: 22px;">
                    üìê Geometric Intuition
                </h3>
                
                <div class="explanation-text">
                    Ridge regression finds the optimal solution by balancing two objectives:
                </div>
                
                <div class="highlight-box">
                    <strong style="font-size: 18px;">1Ô∏è‚É£ Minimize Prediction Error (RSS)</strong><br>
                    <span style="font-size: 16px;">Want to fit the training data well</span>
                </div>
                
                <div class="highlight-box">
                    <strong style="font-size: 18px;">2Ô∏è‚É£ Minimize Coefficient Magnitude (Œª‚àëŒ≤¬≤)</strong><br>
                    <span style="font-size: 16px;">Want to keep the model simple</span>
                </div>
                
                <div class="formula-box">
                    <div class="formula-text">
                        Loss = RSS + Œª‚àëŒ≤·µ¢¬≤
                    </div>
                    <div style="margin-top: 15px; font-size: 16px; color: #666; line-height: 1.6;">
                        The solution moves from the RSS optimal point<br>
                        toward the origin (Œ≤=0) as Œª increases
                    </div>
                </div>
                
                <canvas id="geometricCanvas" width="860" height="450"></canvas>
                
                <div class="explanation-text" style="margin-top: 25px; font-size: 16px;">
                    <strong style="color: #28a745;">üéØ Key Insight:</strong> L2 penalty creates a circular constraint. 
                    The optimal solution is where the RSS contour (ellipse) touches the L2 constraint circle.
                    As Œª increases, the circle gets smaller, pulling coefficients toward zero.
                </div>
            </div>
        </div>
        
        <!-- Multicollinearity Explanation -->
        <div class="section">
            <div class="multicollinearity-box">
                <h3 style="text-align: center; color: #f57c00; margin-bottom: 25px; font-size: 22px;">
                    üí° Why Ridge Helps with Multicollinearity
                </h3>
                
                <div class="explanation-text">
                    When features are highly correlated (multicollinear), ordinary linear regression 
                    can produce very large coefficients that cancel each other out.
                </div>
                
                <div class="highlight-box highlight-box-yellow">
                    <strong style="font-size: 18px;">‚ö†Ô∏è Problem Example:</strong><br>
                    <span style="font-size: 16px;">If x‚ÇÅ ‚âà x‚ÇÇ:</span><br>
                    <code style="font-size: 17px; background: white; padding: 8px 12px; border-radius: 5px; display: inline-block; margin-top: 8px;">
                        y = 100¬∑x‚ÇÅ - 99¬∑x‚ÇÇ
                    </code><br><br>
                    <span style="font-size: 16px;">These large coefficients are unstable and sensitive to small data changes!</span>
                </div>
                
                <div class="highlight-box">
                    <strong style="font-size: 18px; color: #28a745;">‚úÖ Ridge Solution:</strong><br>
                    <span style="font-size: 16px;">By penalizing large coefficients:</span><br>
                    <code style="font-size: 17px; background: white; padding: 8px 12px; border-radius: 5px; display: inline-block; margin-top: 8px; border: 2px solid #28a745;">
                        y = 1.5¬∑x‚ÇÅ + 0.5¬∑x‚ÇÇ
                    </code><br><br>
                    <span style="font-size: 16px; font-weight: 600; color: #28a745;">
                        The model becomes more stable and generalizes better!
                    </span>
                </div>
                
                <canvas id="multicollinearityCanvas" width="860" height="300"></canvas>
            </div>
        </div>

        <!-- 3D Visualization Section -->
        <div class="section">
            <div class="section-title">üé≤ 3D Loss Surface Visualization</div>
            
            <div class="viz-subtitle">
                Compare how the loss surface changes with and without L2 regularization.<br>
                The white sphere marks the optimal coefficient values.
            </div>
            
            <div class="viz-container-3d">
                <div class="canvas-wrapper">
                    <div class="canvas-header">Ordinary Least Squares (OLS)</div>
                    <canvas id="canvas-ols"></canvas>
                </div>
                
                <div class="canvas-wrapper">
                    <div class="canvas-header">Ridge Regression (L2)</div>
                    <canvas id="canvas-ridge"></canvas>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-row">
                    <span class="control-label">Œª (Lambda):</span>
                    <input type="range" id="lambda-slider" class="control-slider" min="0" max="10" step="0.1" value="1">
                    <span class="control-value" id="lambda-value">1.0</span>
                </div>
                
                <div class="control-row">
                    <span class="control-label">Rotation Speed:</span>
                    <input type="range" id="rotation-slider" class="control-slider" min="0" max="5" step="0.1" value="1">
                    <span class="control-value" id="rotation-value">1.0</span>
                </div>
                
                <p style="font-size: 14px; color: #666; margin-top: 15px; line-height: 1.6;">
                    üí° <strong>Tip:</strong> Increase Œª to see how the optimal point (white sphere) moves closer to the origin (red sphere at center), 
                    representing smaller coefficient values and a simpler model.
                </p>
            </div>
        </div>
    </div>

    <script>
        // ========== 2D Visualization Code ==========
        const originalCoeffs = [5.0, 3.0, 4.0];
        const lambdaHistory = [];
        const coeffHistory = [[], [], []];
        
        // Draw L2 (Circle) shape
        function drawL2Shape() {
            const canvas = document.getElementById('l2Canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const centerX = 140;
            const centerY = 140;
            const radius = 100;
            
            ctx.clearRect(0, 0, 280, 280);
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, centerY);
            ctx.lineTo(260, centerY);
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, 260);
            ctx.stroke();
            
            // Draw L2 circles with different lambdas
            const lambdas = [1, 0.5, 0.25];
            const opacities = [1, 0.6, 0.3];
            
            lambdas.forEach((lambda, i) => {
                ctx.strokeStyle = `rgba(30, 100, 200, ${opacities[i]})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * lambda, 0, 2 * Math.PI);
                ctx.stroke();
            });
            
            // Draw solution point
            ctx.fillStyle = '#28a745';
            ctx.beginPath();
            ctx.arc(centerX + radius * 0.5 * 0.7, centerY - radius * 0.5 * 0.7, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('w‚ÇÅ', 245, centerY - 8);
            ctx.fillText('w‚ÇÄ', centerX + 8, 35);
            
            // Lambda labels
            ctx.font = '13px Arial';
            ctx.fillStyle = '#1E64C8';
            ctx.fillText('Œª = 0.25', centerX + radius * 0.25 + 10, centerY - radius * 0.25 - 10);
        }
        
        // Draw L1 (Diamond) shape
        function drawL1Shape() {
            const canvas = document.getElementById('l1Canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const centerX = 140;
            const centerY = 140;
            const size = 100;
            
            ctx.clearRect(0, 0, 280, 280);
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, centerY);
            ctx.lineTo(260, centerY);
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, 260);
            ctx.stroke();
            
            // Draw L1 diamonds with different lambdas
            const lambdas = [1, 0.6, 0.3];
            const opacities = [1, 0.6, 0.3];
            
            lambdas.forEach((lambda, i) => {
                ctx.strokeStyle = `rgba(220, 53, 69, ${opacities[i]})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY - size * lambda);
                ctx.lineTo(centerX + size * lambda, centerY);
                ctx.lineTo(centerX, centerY + size * lambda);
                ctx.lineTo(centerX - size * lambda, centerY);
                ctx.closePath();
                ctx.stroke();
            });
            
            // Draw point at corner (sparse solution)
            ctx.fillStyle = '#dc3545';
            ctx.beginPath();
            ctx.arc(centerX + size * 0.6, centerY, 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('w‚ÇÅ', 245, centerY - 8);
            ctx.fillText('w‚ÇÄ', centerX + 8, 35);
            
            // Note about sparsity
            ctx.font = '12px Arial';
            ctx.fillStyle = '#dc3545';
            ctx.fillText('w‚ÇÄ = 0', centerX + size * 0.6 + 10, centerY - 10);
        }
        
        // Lambda slider functionality
        const lambdaSlider = document.getElementById('lambdaSlider');
        const lambdaValue = document.getElementById('lambdaValue');
        const coeff1El = document.getElementById('coeff1');
        const coeff2El = document.getElementById('coeff2');
        const coeff3El = document.getElementById('coeff3');
        
        lambdaSlider.addEventListener('input', function() {
            const lambda = parseFloat(this.value) / 10;
            lambdaValue.textContent = lambda.toFixed(1);
            
            // Calculate shrunk coefficients using Ridge formula
            const shrinkFactor = 1 / (1 + lambda * 0.5);
            const newCoeffs = originalCoeffs.map(c => c * shrinkFactor);
            
            coeff1El.textContent = newCoeffs[0].toFixed(2);
            coeff2El.textContent = newCoeffs[1].toFixed(2);
            coeff3El.textContent = newCoeffs[2].toFixed(2);
            
            // Store history
            lambdaHistory.push(lambda);
            newCoeffs.forEach((c, i) => coeffHistory[i].push(c));
            
            // Keep only last 50 points
            if (lambdaHistory.length > 50) {
                lambdaHistory.shift();
                coeffHistory.forEach(h => h.shift());
            }
            
            drawCoefficientChart();
        });
        
        // Draw coefficient chart
        function drawCoefficientChart() {
            const canvas = document.getElementById('coeffChart');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 50;
            
            ctx.clearRect(0, 0, width, height);
            
            // Background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (height - 2 * padding) * i / 5;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Coefficient Value', 10, 30);
            ctx.fillText('Œª ‚Üí', width - 70, height - 15);
            
            // Y-axis labels
            ctx.font = '13px Arial';
            for (let i = 0; i <= 5; i++) {
                const value = (5 - i).toFixed(0);
                const y = padding + (height - 2 * padding) * i / 5;
                ctx.fillText(value, 20, y + 5);
            }
            
            if (lambdaHistory.length < 2) return;
            
            const maxLambda = 10;
            const maxCoeff = 5;
            
            const colors = ['#1E64C8', '#28a745', '#ffc107'];
            const labels = ['Œ≤‚ÇÅ', 'Œ≤‚ÇÇ', 'Œ≤‚ÇÉ'];
            
            // Draw lines
            coeffHistory.forEach((history, idx) => {
                ctx.strokeStyle = colors[idx];
                ctx.lineWidth = 4;
                ctx.beginPath();
                
                history.forEach((coeff, i) => {
                    const x = padding + (lambdaHistory[i] / maxLambda) * (width - 2 * padding);
                    const y = height - padding - (coeff / maxCoeff) * (height - 2 * padding);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                
                ctx.stroke();
                
                // Draw dots at end
                if (history.length > 0) {
                    const lastI = history.length - 1;
                    const x = padding + (lambdaHistory[lastI] / maxLambda) * (width - 2 * padding);
                    const y = height - padding - (history[lastI] / maxCoeff) * (height - 2 * padding);
                    ctx.fillStyle = colors[idx];
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // Draw legend
                const legendX = width - padding - 200;
                const legendY = padding + 20 + idx * 30;
                ctx.fillStyle = colors[idx];
                ctx.fillRect(legendX, legendY - 5, 30, 4);
                ctx.fillStyle = '#333';
                ctx.font = 'bold 15px Arial';
                ctx.fillText(labels[idx] + ' (original: ' + originalCoeffs[idx].toFixed(1) + ')', legendX + 40, legendY);
            });
        }
        
        // Draw geometric visualization
        function drawGeometricVisualization() {
            const canvas = document.getElementById('geometricCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            
            ctx.clearRect(0, 0, width, height);
            
            // Background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, centerY);
            ctx.lineTo(width - 50, centerY);
            ctx.moveTo(centerX, 50);
            ctx.lineTo(centerX, height - 50);
            ctx.stroke();
            
            // Draw RSS contours (ellipses) - moved to upper right
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.ellipse(centerX + 120, centerY - 80, 50 * i, 35 * i, -0.3, 0, 2 * Math.PI);
                ctx.stroke();
            }
            ctx.setLineDash([]);
            
            // Draw L2 constraint circles
            ctx.strokeStyle = '#1E64C8';
            ctx.lineWidth = 3;
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, 60 * i, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Mark RSS optimal point
            ctx.fillStyle = '#dc3545';
            ctx.beginPath();
            ctx.arc(centerX + 120, centerY - 80, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Mark Ridge optimal point
            ctx.fillStyle = '#28a745';
            ctx.beginPath();
            ctx.arc(centerX + 85, centerY - 55, 10, 0, 2 * Math.PI);
            ctx.fill();
            
            // Mark origin
            ctx.fillStyle = '#ffc107';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw arrow showing movement
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(centerX + 120, centerY - 80);
            ctx.lineTo(centerX + 85, centerY - 55);
            ctx.stroke();
            
            // Arrowhead
            const angle = Math.atan2(-25, -35);
            ctx.beginPath();
            ctx.moveTo(centerX + 85, centerY - 55);
            ctx.lineTo(centerX + 85 - 15*Math.cos(angle-0.3), centerY - 55 - 15*Math.sin(angle-0.3));
            ctx.moveTo(centerX + 85, centerY - 55);
            ctx.lineTo(centerX + 85 - 15*Math.cos(angle+0.3), centerY - 55 - 15*Math.sin(angle+0.3));
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Œ≤‚ÇÅ', width - 70, centerY - 8);
            ctx.fillText('Œ≤‚ÇÄ', centerX + 8, 65);
            
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#dc3545';
            ctx.fillText('RSS Minimum', centerX + 135, centerY - 95);
            
            ctx.fillStyle = '#28a745';
            ctx.fillText('Ridge Solution', centerX + 100, centerY - 35);
            
            ctx.fillStyle = '#ffc107';
            ctx.fillText('Origin (Œ≤=0)', centerX + 15, centerY + 25);
            
            ctx.font = '13px Arial';
            ctx.fillStyle = '#dc3545';
            ctx.fillText('‚Üê RSS Contours', centerX + 220, centerY - 150);
            
            ctx.fillStyle = '#1E64C8';
            ctx.fillText('L2 Constraint ‚Üí', centerX - 220, centerY + 120);
            
            ctx.fillStyle = '#28a745';
            ctx.fillText('Movement as Œª increases', centerX + 20, centerY - 70);
        }
        
        // Draw multicollinearity comparison chart
        function drawMulticollinearityChart() {
            const canvas = document.getElementById('multicollinearityCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Background
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            const barWidth = 80;
            const spacing = 100;
            const startX = 150;
            
            // Without Ridge (large coefficients)
            ctx.fillStyle = '#dc3545';
            ctx.fillRect(startX, 100, barWidth, -100 * 1);  // Œ≤1 = 100
            ctx.fillStyle = '#c82333';
            ctx.fillRect(startX + barWidth + 20, 100, barWidth, 99 * 1);  // Œ≤2 = -99
            
            // Labels for without Ridge
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Ordinary Regression', startX + 10, 130);
            ctx.font = '14px Arial';
            ctx.fillText('Œ≤‚ÇÅ = 100', startX + 10, 20);
            ctx.fillText('Œ≤‚ÇÇ = -99', startX + barWidth + 25, 220);
            
            // Divider
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(width / 2, 50);
            ctx.lineTo(width / 2, height - 50);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // With Ridge (small coefficients)
            const ridge_x = width / 2 + spacing;
            ctx.fillStyle = '#28a745';
            ctx.fillRect(ridge_x, 100, barWidth, -1.5 * 10);  // Œ≤1 = 1.5
            ctx.fillStyle = '#218838';
            ctx.fillRect(ridge_x + barWidth + 20, 100, barWidth, 0.5 * 10);  // Œ≤2 = 0.5
            
            // Labels for with Ridge
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Ridge Regression', ridge_x + 20, 130);
            ctx.font = '14px Arial';
            ctx.fillText('Œ≤‚ÇÅ = 1.5', ridge_x + 15, 90);
            ctx.fillText('Œ≤‚ÇÇ = 0.5', ridge_x + barWidth + 25, 110);
            
            // Title
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.fillText('Coefficient Magnitude Comparison: With Multicollinearity', width / 2, 280);
            ctx.textAlign = 'left';
            
            // Axis
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(100, 100);
            ctx.lineTo(width - 100, 100);
            ctx.stroke();
            
            // 0 line label
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText('0', 90, 105);
        }
        
        // Initialize 2D visualizations
        drawL2Shape();
        drawL1Shape();
        drawCoefficientChart();
        drawGeometricVisualization();
        drawMulticollinearityChart();

        // ========== 3D Visualization Code ==========
        let sceneOLS, cameraOLS, rendererOLS;
        let sceneRidge, cameraRidge, rendererRidge;
        let surfaceOLS, surfaceRidge;
        let markerOLS, markerRidge;
        let lambda = 1.0;
        let rotationSpeed = 1.0;

        function initScene(canvasId, isRidge) {
            const canvas = document.getElementById(canvasId);
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);

            const camera = new THREE.PerspectiveCamera(
                50,
                canvas.clientWidth / canvas.clientHeight,
                0.1,
                1000
            );
            camera.position.set(15, 12, 15);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true 
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Add coordinate labels
            createCoordinateLabels(scene);

            return { scene, camera, renderer };
        }

        function createLossSurface(lambda = 0) {
            const geometry = new THREE.BufferGeometry();
            const resolution = 50;
            const range = 10;
            const step = (2 * range) / resolution;

            const vertices = [];
            const colors = [];
            const indices = [];

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = -range + i * step;
                    const z = -range + j * step;
                    
                    // RSS component (paraboloid centered at (2, 1))
                    const rss = Math.pow(x - 2, 2) + 2 * Math.pow(z - 1, 2);
                    
                    // L2 penalty component (circular bowl centered at origin)
                    const l2_penalty = lambda * (x * x + z * z);
                    
                    // Total loss
                    const y = rss + l2_penalty;
                    
                    vertices.push(x, y * 0.1, z); // Scale y for better visualization

                    // Color based on height (loss value)
                    const normalizedY = Math.min(y / 50, 1);
                    const color = new THREE.Color();
                    
                    // Blue (low) -> Green -> Yellow -> Red (high)
                    if (normalizedY < 0.33) {
                        color.setRGB(0, normalizedY * 3, 1 - normalizedY * 3);
                    } else if (normalizedY < 0.66) {
                        const t = (normalizedY - 0.33) * 3;
                        color.setRGB(t, 1, 0);
                    } else {
                        const t = (normalizedY - 0.66) * 3;
                        color.setRGB(1, 1 - t, 0);
                    }
                    
                    colors.push(color.r, color.g, color.b);
                }
            }

            // Create faces
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const a = i * (resolution + 1) + j;
                    const b = a + resolution + 1;
                    const c = a + 1;
                    const d = b + 1;

                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 30,
                transparent: true,
                opacity: 0.85
            });

            return new THREE.Mesh(geometry, material);
        }

        function createCoordinateLabels(scene) {
            // Create text sprites for axis labels
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            function createTextSprite(text, color = '#1E64C8') {
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.font = 'Bold 48px Arial';
                context.fillStyle = color;
                context.textAlign = 'center';
                context.fillText(text, 128, 80);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 1, 1);
                return sprite;
            }

            // Add axis labels
            const labelX = createTextSprite('Œ≤‚ÇÅ');
            labelX.position.set(11, 0, 0);
            scene.add(labelX);

            const labelZ = createTextSprite('Œ≤‚ÇÇ');
            labelZ.position.set(0, 0, 11);
            scene.add(labelZ);

            const labelY = createTextSprite('Loss');
            labelY.position.set(0, 11, 0);
            scene.add(labelY);

            // Add origin marker
            const originGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const originMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.3
            });
            const originMarker = new THREE.Mesh(originGeometry, originMaterial);
            originMarker.position.set(0, 0, 0);
            scene.add(originMarker);

            // Add origin label
            const originLabel = createTextSprite('(0,0)', '#ff0000');
            originLabel.position.set(0, -1, 0);
            originLabel.scale.set(1.5, 0.75, 1);
            scene.add(originLabel);

            // Add reference grid lines at y=0 plane
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x1E64C8, opacity: 0.3, transparent: true });
            
            // X-axis line
            const xLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-10, 0, 0),
                new THREE.Vector3(10, 0, 0)
            ]);
            const xLine = new THREE.Line(xLineGeometry, lineMaterial);
            scene.add(xLine);

            // Z-axis line
            const zLineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -10),
                new THREE.Vector3(0, 0, 10)
            ]);
            const zLine = new THREE.Line(zLineGeometry, lineMaterial);
            scene.add(zLine);
        }

        function createOptimalPointMarker(lambda = 0) {
            // Calculate approximate optimal point
            // For OLS: around (2, 1)
            // For Ridge: shrunk towards (0, 0)
            const shrinkage = lambda / (1 + lambda);
            const x = 2 * (1 - shrinkage * 0.7);
            const z = 1 * (1 - shrinkage * 0.7);
            
            const rss = Math.pow(x - 2, 2) + 2 * Math.pow(z - 1, 2);
            const l2_penalty = lambda * (x * x + z * z);
            const y = (rss + l2_penalty) * 0.1;

            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                emissive: 0x1E64C8,
                emissiveIntensity: 0.5
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y + 0.5, z);

            // Add a cylinder as a marker line
            const cylinderGeometry = new THREE.CylinderGeometry(0.05, 0.05, y + 0.5, 8);
            const cylinderMaterial = new THREE.MeshPhongMaterial({ color: 0x1E64C8 });
            const cylinder = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
            cylinder.position.set(x, (y + 0.5) / 2, z);

            const group = new THREE.Group();
            group.add(sphere);
            group.add(cylinder);

            return group;
        }

        function init3D() {
            // Initialize OLS scene
            const olsSetup = initScene('canvas-ols', false);
            sceneOLS = olsSetup.scene;
            cameraOLS = olsSetup.camera;
            rendererOLS = olsSetup.renderer;

            // Initialize Ridge scene
            const ridgeSetup = initScene('canvas-ridge', true);
            sceneRidge = ridgeSetup.scene;
            cameraRidge = ridgeSetup.camera;
            rendererRidge = ridgeSetup.renderer;

            // Create surfaces
            updateSurfaces();

            // Event listeners
            document.getElementById('lambda-slider').addEventListener('input', (e) => {
                lambda = parseFloat(e.target.value);
                document.getElementById('lambda-value').textContent = lambda.toFixed(1);
                updateSurfaces();
            });

            document.getElementById('rotation-slider').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotation-value').textContent = rotationSpeed.toFixed(1);
            });

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            animate3D();
        }

        function updateSurfaces() {
            // Remove old surfaces
            if (surfaceOLS) sceneOLS.remove(surfaceOLS);
            if (surfaceRidge) sceneRidge.remove(surfaceRidge);
            if (markerOLS) sceneOLS.remove(markerOLS);
            if (markerRidge) sceneRidge.remove(markerRidge);

            // Create new surfaces
            surfaceOLS = createLossSurface(0); // OLS has no regularization
            surfaceRidge = createLossSurface(lambda);

            sceneOLS.add(surfaceOLS);
            sceneRidge.add(surfaceRidge);

            // Create optimal point markers
            markerOLS = createOptimalPointMarker(0);
            markerRidge = createOptimalPointMarker(lambda);

            sceneOLS.add(markerOLS);
            sceneRidge.add(markerRidge);
        }

        function onWindowResize() {
            const canvasOLS = document.getElementById('canvas-ols');
            const canvasRidge = document.getElementById('canvas-ridge');

            if (canvasOLS && cameraOLS && rendererOLS) {
                cameraOLS.aspect = canvasOLS.clientWidth / canvasOLS.clientHeight;
                cameraOLS.updateProjectionMatrix();
                rendererOLS.setSize(canvasOLS.clientWidth, canvasOLS.clientHeight);
            }

            if (canvasRidge && cameraRidge && rendererRidge) {
                cameraRidge.aspect = canvasRidge.clientWidth / canvasRidge.clientHeight;
                cameraRidge.updateProjectionMatrix();
                rendererRidge.setSize(canvasRidge.clientWidth, canvasRidge.clientHeight);
            }
        }

        function animate3D() {
            requestAnimationFrame(animate3D);

            // Rotate both scenes
            if (surfaceOLS) {
                surfaceOLS.rotation.y += 0.001 * rotationSpeed;
                markerOLS.rotation.y += 0.001 * rotationSpeed;
            }
            if (surfaceRidge) {
                surfaceRidge.rotation.y += 0.001 * rotationSpeed;
                markerRidge.rotation.y += 0.001 * rotationSpeed;
            }

            if (rendererOLS && sceneOLS && cameraOLS) {
                rendererOLS.render(sceneOLS, cameraOLS);
            }
            if (rendererRidge && sceneRidge && cameraRidge) {
                rendererRidge.render(sceneRidge, cameraRidge);
            }
        }

        // Initialize 3D visualization when page loads
        window.addEventListener('load', init3D);
    </script>
</body>
</html>