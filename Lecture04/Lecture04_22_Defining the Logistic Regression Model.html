<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defining the Logistic Regression Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Aptos, 'Segoe UI', sans-serif;
            background: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            width: 960px;
            height: 540px;
            background: white;
            padding: 30px;
            position: relative;
        }
        
        .title {
            font-size: 20px;
            font-weight: 600;
            color: #1E64C8;
            margin-bottom: 18px;
            text-align: center;
        }
        
        .content-layout {
            display: flex;
            flex-direction: column;
            gap: 15px;
            height: calc(100% - 50px);
        }
        
        .formula-box {
            background: linear-gradient(135deg, #1E64C8 0%, #2874d8 100%);
            border-radius: 10px;
            padding: 20px 24px;
            color: white;
            text-align: center;
        }
        
        .formula-label {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            opacity: 0.95;
        }
        
        .formula-main {
            font-size: 20px;
            font-weight: 700;
            font-style: italic;
            margin-bottom: 8px;
        }
        
        .formula-expanded {
            font-size: 18px;
            font-weight: 600;
            font-style: italic;
            opacity: 0.95;
        }
        
        .architecture-flow {
            display: flex;
            align-items: center;
            gap: 12px;
            background: #f8f9fa;
            border: 2px solid #1E64C8;
            border-radius: 10px;
            padding: 16px 20px;
        }
        
        .flow-step {
            flex: 1;
            background: white;
            border: 2px solid #1E64C8;
            border-radius: 8px;
            padding: 14px 16px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .flow-step:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(30, 100, 200, 0.2);
        }
        
        .step-label {
            font-size: 14px;
            color: #666;
            margin-bottom: 6px;
            font-weight: 600;
        }
        
        .step-content {
            font-size: 17px;
            color: #1E64C8;
            font-weight: 600;
            font-style: italic;
        }
        
        .step-desc {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }
        
        .arrow-flow {
            font-size: 28px;
            color: #1E64C8;
            font-weight: bold;
        }
        
        .sigmoid-step {
            border-color: #9c27b0;
        }
        
        .sigmoid-step .step-content {
            color: #9c27b0;
        }
        
        .output-step {
            border-color: #28a745;
        }
        
        .output-step .step-content {
            color: #28a745;
        }
        
        .decision-section {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 12px;
            align-items: center;
        }
        
        .decision-box {
            background: white;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 14px 16px;
            text-align: center;
        }
        
        .decision-label {
            font-size: 15px;
            color: #f57c00;
            font-weight: 600;
            margin-bottom: 6px;
        }
        
        .decision-rule {
            font-size: 17px;
            color: #333;
            font-weight: 600;
        }
        
        .threshold-icon {
            font-size: 24px;
            color: #ffc107;
        }
        
        .note-box {
            background: #fff8e6;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 10px 14px;
            text-align: center;
            font-size: 15px;
            color: #f57c00;
            font-weight: 500;
        }
        
        .parameters-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }
        
        .param-card {
            background: white;
            border: 2px solid #1E64C8;
            border-left: 5px solid #1E64C8;
            border-radius: 8px;
            padding: 14px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .param-icon {
            width: 32px;
            height: 32px;
            background: #1E64C8;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .param-content {
            flex: 1;
        }
        
        .param-name {
            font-size: 16px;
            font-weight: 600;
            color: #1E64C8;
            margin-bottom: 4px;
        }
        
        .param-desc {
            font-size: 15px;
            color: #555;
        }
        
        .goal-box {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            border-radius: 8px;
            padding: 14px 18px;
            color: white;
            text-align: center;
            font-size: 17px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">Defining the Logistic Regression Model</div>
        
        <div class="content-layout">
            <!-- Complete Formula -->
            <div class="formula-box">
                <div class="formula-label">Complete Formulation:</div>
                <div class="formula-main">P(y=1|x) = œÉ(w·µÄx + b)</div>
                <div class="formula-expanded">= 1 / (1 + e‚Åª‚ÅΩ ∑·µÄÀ£‚Å∫·µá‚Åæ)</div>
            </div>
            
            <!-- Architecture Flow -->
            <div class="architecture-flow">
                <div class="flow-step">
                    <div class="step-label">Step 1</div>
                    <div class="step-content">w·µÄx + b</div>
                    <div class="step-desc">Linear combination</div>
                </div>
                
                <div class="arrow-flow">‚Üí</div>
                
                <div class="flow-step sigmoid-step">
                    <div class="step-label">Step 2</div>
                    <div class="step-content">œÉ(...)</div>
                    <div class="step-desc">Sigmoid function</div>
                </div>
                
                <div class="arrow-flow">‚Üí</div>
                
                <div class="flow-step output-step">
                    <div class="step-label">Output</div>
                    <div class="step-content">P ‚àà [0,1]</div>
                    <div class="step-desc">Probability</div>
                </div>
            </div>
            
            <!-- Decision Rule -->
            <div class="decision-section">
                <div class="decision-box">
                    <div class="decision-label">Decision Rule:</div>
                    <div class="decision-rule">Predict Class 1 if<br>P(y=1|x) ‚â• 0.5</div>
                </div>
                
                <div class="threshold-icon">‚öô</div>
                
                <div class="note-box">
                    Threshold can be adjusted based on application needs
                </div>
            </div>
            
            <!-- Parameters -->
            <div class="parameters-section">
                <div class="param-card">
                    <div class="param-icon">w</div>
                    <div class="param-content">
                        <div class="param-name">Weight Vector w</div>
                        <div class="param-desc">Model parameters to learn</div>
                    </div>
                </div>
                
                <div class="param-card">
                    <div class="param-icon">b</div>
                    <div class="param-content">
                        <div class="param-name">Bias b</div>
                        <div class="param-desc">Intercept term to learn</div>
                    </div>
                </div>
            </div>
            
            <!-- Training Goal -->
            <div class="goal-box">
                Training Goal: Find optimal w and b from data
            </div>
            
            <!-- Visualization Section Title -->
            <div style="text-align: center; margin-top: 30px; margin-bottom: 15px;">
                <h2 style="color: #1E64C8; font-size: 22px; font-weight: 600;">Input-Output Visualization</h2>
            </div>
            
            <!-- 2D and 3D Visualizations -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <!-- 2D Visualization -->
                <div style="background: white; border: 2px solid #1E64C8; border-radius: 10px; padding: 20px;">
                    <div style="text-align: center; color: #1E64C8; font-weight: 600; font-size: 16px; margin-bottom: 15px;">
                        2D: Single Feature (x‚ÇÅ)
                    </div>
                    <canvas id="canvas2d" width="400" height="300"></canvas>
                    <div style="text-align: center; margin-top: 10px; font-size: 13px; color: #666;">
                        Sigmoid curve: P(y=1|x‚ÇÅ) = œÉ(w‚ÇÅx‚ÇÅ + b)
                    </div>
                </div>
                
                <!-- 3D Visualization -->
                <div style="background: white; border: 2px solid #1E64C8; border-radius: 10px; padding: 20px;">
                    <div style="text-align: center; color: #1E64C8; font-weight: 600; font-size: 16px; margin-bottom: 15px;">
                        3D: Two Features (x‚ÇÅ, x‚ÇÇ)
                    </div>
                    <div id="canvas3d" style="width: 400px; height: 300px;"></div>
                    <div style="text-align: center; margin-top: 10px; font-size: 13px; color: #666;">
                        Decision surface: P(y=1|x‚ÇÅ,x‚ÇÇ) = œÉ(w‚ÇÅx‚ÇÅ + w‚ÇÇx‚ÇÇ + b)
                        <br><span style="color: #1E64C8; font-weight: 600;">üñ±Ô∏è Drag to rotate, scroll to zoom</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 2D Visualization - Sigmoid Curve
        function draw2DVisualization() {
            const canvas = document.getElementById('canvas2d');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // Parameters for sigmoid
            const w = 2;
            const b = 0;
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Y-axis
            ctx.moveTo(50, 20);
            ctx.lineTo(50, height - 40);
            // X-axis
            ctx.lineTo(width - 20, height - 40);
            ctx.stroke();
            
            // Y-axis labels (probability: 0 to 1)
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('1.0', 45, 25);
            ctx.fillText('0.5', 45, height/2);
            ctx.fillText('0.0', 45, height - 35);
            
            // X-axis labels
            ctx.textAlign = 'center';
            ctx.fillText('-3', 80, height - 20);
            ctx.fillText('0', width/2, height - 20);
            ctx.fillText('3', width - 50, height - 20);
            
            // Axis labels
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#1E64C8';
            ctx.fillText('P(y=1|x‚ÇÅ)', 25, height/2);
            ctx.fillText('x‚ÇÅ', width - 20, height - 5);
            
            // Draw sigmoid curve
            ctx.strokeStyle = '#1E64C8';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            const xMin = -5;
            const xMax = 5;
            const steps = 200;
            
            for (let i = 0; i <= steps; i++) {
                const x = xMin + (xMax - xMin) * i / steps;
                const z = w * x + b;
                const y = 1 / (1 + Math.exp(-z));
                
                // Map to canvas coordinates
                const canvasX = 50 + (x - xMin) / (xMax - xMin) * (width - 70);
                const canvasY = (height - 40) - y * (height - 60);
                
                if (i === 0) {
                    ctx.moveTo(canvasX, canvasY);
                } else {
                    ctx.lineTo(canvasX, canvasY);
                }
            }
            ctx.stroke();
            
            // Draw threshold line at 0.5
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            const thresholdY = (height - 40) - 0.5 * (height - 60);
            ctx.moveTo(50, thresholdY);
            ctx.lineTo(width - 20, thresholdY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Add threshold label
            ctx.fillStyle = '#f57c00';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Threshold = 0.5', width - 120, thresholdY - 5);
            
            // Draw sample points
            const samplePoints = [
                {x: -2, label: 'Class 0'},
                {x: 2, label: 'Class 1'}
            ];
            
            samplePoints.forEach(point => {
                const z = w * point.x + b;
                const prob = 1 / (1 + Math.exp(-z));
                const canvasX = 50 + (point.x - xMin) / (xMax - xMin) * (width - 70);
                const canvasY = (height - 40) - prob * (height - 60);
                
                ctx.fillStyle = prob >= 0.5 ? '#28a745' : '#dc3545';
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        // 3D Visualization with Three.js - Interactive Decision Surface
        function draw3DVisualization() {
            const container = document.getElementById('canvas3d');
            
            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            // Camera setup
            const camera = new THREE.PerspectiveCamera(45, 400/300, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(400, 300);
            container.appendChild(renderer.domElement);
            
            // Parameters
            const w1 = 1.5;
            const w2 = 1.5;
            const b = -2;
            
            // Create decision surface
            const gridSize = 50;
            const range = 3;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const indices = [];
            
            // Generate vertices and colors
            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize; j++) {
                    const x1 = -range + (2 * range * i / gridSize);
                    const x2 = -range + (2 * range * j / gridSize);
                    
                    // Calculate probability
                    const z = w1 * x1 + w2 * x2 + b;
                    const prob = 1 / (1 + Math.exp(-z));
                    
                    vertices.push(x1, prob * 2, x2); // Scale prob for better visualization
                    
                    // Color based on probability (blue to red gradient)
                    const red = prob;
                    const blue = 1 - prob;
                    colors.push(red, 0.4, blue);
                }
            }
            
            // Generate indices for triangles
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const a = i * (gridSize + 1) + j;
                    const b = a + gridSize + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 30,
                transparent: true,
                opacity: 0.9
            });
            
            const surface = new THREE.Mesh(geometry, material);
            scene.add(surface);
            
            // Add decision boundary line (where P = 0.5)
            const boundaryGeometry = new THREE.BufferGeometry();
            const boundaryVertices = [];
            const boundaryPoints = 100;
            
            for (let i = 0; i <= boundaryPoints; i++) {
                const t = i / boundaryPoints;
                const x1 = -range + 2 * range * t;
                const x2 = -(w1 * x1 + b) / w2;
                
                if (Math.abs(x2) <= range) {
                    boundaryVertices.push(x1, 1, x2); // P = 0.5 scaled to z = 1
                }
            }
            
            boundaryGeometry.setAttribute('position', new THREE.Float32BufferAttribute(boundaryVertices, 3));
            const boundaryMaterial = new THREE.LineBasicMaterial({ color: 0xffc107, linewidth: 3 });
            const boundaryLine = new THREE.Line(boundaryGeometry, boundaryMaterial);
            scene.add(boundaryLine);
            
            // Add sample points
            const samples = [
                {x1: -1.5, x2: -1.5, cls: 0},
                {x1: 1.5, x2: 1.5, cls: 1},
                {x1: -1, x2: 1, cls: 0},
                {x1: 1, x2: -1, cls: 1}
            ];
            
            samples.forEach(s => {
                const z = w1 * s.x1 + w2 * s.x2 + b;
                const prob = 1 / (1 + Math.exp(-z));
                
                const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: s.cls === 1 ? 0x28a745 : 0xdc3545
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(s.x1, prob * 2, s.x2);
                scene.add(sphere);
            });
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(3.5);
            scene.add(axesHelper);
            
            // Add grid
            const gridHelper = new THREE.GridHelper(6, 12, 0x1E64C8, 0xcccccc);
            gridHelper.rotation.x = 0;
            scene.add(gridHelper);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Mouse interaction variables
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };
            
            // Mouse event handlers
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    rotation.y += deltaX * 0.01;
                    rotation.x += deltaY * 0.01;
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Zoom with mouse wheel
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const delta = e.deltaY > 0 ? 1 : -1;
                
                camera.position.multiplyScalar(1 + delta * zoomSpeed);
                camera.position.clampLength(3, 20);
            });
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Apply rotation
                camera.position.x = Math.cos(rotation.y) * Math.cos(rotation.x) * camera.position.length();
                camera.position.y = Math.sin(rotation.x) * camera.position.length();
                camera.position.z = Math.sin(rotation.y) * Math.cos(rotation.x) * camera.position.length();
                camera.lookAt(0, 0, 0);
                
                renderer.render(scene, camera);
            }
            
            animate();
        }
        
        // Draw both visualizations on page load
        window.addEventListener('load', function() {
            draw2DVisualization();
            draw3DVisualization();
        });
    </script>
</body>
</html>