<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Cross-Entropy Loss</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Aptos, 'Segoe UI', sans-serif;
            background: white;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
        }
        
        .title {
            font-size: 28px;
            font-weight: 600;
            color: #1E64C8;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .content-layout {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .loss-formula-box {
            background: linear-gradient(135deg, #1E64C8 0%, #2874d8 100%);
            border-radius: 10px;
            padding: 25px;
            color: white;
            text-align: center;
        }
        
        .formula-label {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            opacity: 0.95;
        }
        
        .formula-text {
            font-size: 24px;
            font-weight: 700;
            font-style: italic;
        }
        
        .properties-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        
        .property-card {
            background: white;
            border: 2px solid #1E64C8;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .property-card:hover {
            background: #f8fbff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 100, 200, 0.15);
        }
        
        .property-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .property-text {
            font-size: 16px;
            color: #333;
            font-weight: 500;
            line-height: 1.4;
        }
        
        .cases-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }
        
        .case-box {
            background: white;
            border: 3px solid;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .case-1 {
            border-color: #28a745;
        }
        
        .case-0 {
            border-color: #dc3545;
        }
        
        .case-header {
            text-align: center;
            padding: 12px;
            border-radius: 8px;
            color: white;
            font-size: 20px;
            font-weight: 700;
        }
        
        .case-1 .case-header {
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
        }
        
        .case-0 .case-header {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }
        
        .case-loss {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            text-align: center;
        }
        
        .case-loss-label {
            font-size: 16px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .case-loss-formula {
            font-size: 20px;
            font-weight: 700;
            font-style: italic;
        }
        
        .case-1 .case-loss-formula {
            color: #28a745;
        }
        
        .case-0 .case-loss-formula {
            color: #dc3545;
        }
        
        .case-minimize {
            font-size: 16px;
            color: #555;
            text-align: center;
            line-height: 1.4;
        }
        
        .insights-section {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .insight-card {
            background: white;
            border: 2px solid #ffc107;
            border-left: 5px solid #ffc107;
            border-radius: 8px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .insight-icon {
            width: 36px;
            height: 36px;
            background: #ffc107;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .insight-text {
            font-size: 16px;
            color: #333;
            line-height: 1.4;
            flex: 1;
        }
        
        .total-loss-box {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%);
            border-radius: 8px;
            padding: 18px;
            color: white;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
        }
        
        .visualization-section {
            margin-top: 30px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 3px solid #1E64C8;
        }
        
        .viz-title {
            font-size: 26px;
            font-weight: 700;
            color: #1E64C8;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .viz-subtitle {
            font-size: 16px;
            color: #666;
            text-align: center;
            margin-bottom: 20px;
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #dee2e6;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            padding: 10px 20px;
            background: #1E64C8;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: #155a9e;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 100, 200, 0.3);
        }
        
        .viz-description {
            font-size: 15px;
            color: #666;
            line-height: 1.7;
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .viz-description strong {
            color: #1E64C8;
        }
        
        .axis-label {
            display: inline-block;
            padding: 4px 10px;
            margin: 0 3px;
            background: #1E64C8;
            color: white;
            border-radius: 4px;
            font-weight: 600;
            font-size: 14px;
        }
        
        .instruction {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            text-align: center;
            font-size: 14px;
            color: #856404;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">Binary Cross-Entropy Loss</div>
        
        <div class="content-layout">
            <!-- Loss Formula -->
            <div class="loss-formula-box">
                <div class="formula-label">Loss Function:</div>
                <div class="formula-text">L = -[y log(≈∑) + (1-y)log(1-≈∑)]</div>
            </div>
            
            <!-- Properties -->
            <div class="properties-row">
                <div class="property-card">
                    <div class="property-icon">‚ö†</div>
                    <div class="property-text">
                        Penalizes wrong predictions heavily
                    </div>
                </div>
                
                <div class="property-card">
                    <div class="property-icon">‚à™</div>
                    <div class="property-text">
                        Convex function: Guaranteed global minimum
                    </div>
                </div>
                
                <div class="property-card">
                    <div class="property-icon">‚öñ</div>
                    <div class="property-text">
                        Asymmetric penalty: Confident wrong predictions costly
                    </div>
                </div>
            </div>
            
            <!-- Cases -->
            <div class="cases-section">
                <div class="case-box case-1">
                    <div class="case-header">If y = 1</div>
                    <div class="case-loss">
                        <div class="case-loss-label">Loss:</div>
                        <div class="case-loss-formula">-log(≈∑)</div>
                    </div>
                    <div class="case-minimize">
                        Minimized when ≈∑ ‚Üí 1
                    </div>
                </div>
                
                <div class="case-box case-0">
                    <div class="case-header">If y = 0</div>
                    <div class="case-loss">
                        <div class="case-loss-label">Loss:</div>
                        <div class="case-loss-formula">-log(1-≈∑)</div>
                    </div>
                    <div class="case-minimize">
                        Minimized when ≈∑ ‚Üí 0
                    </div>
                </div>
            </div>
            
            <!-- Insights -->
            <div class="insights-section">
                <div class="insight-card">
                    <div class="insight-icon">üí°</div>
                    <div class="insight-text">
                        Asymmetric penalty structure
                    </div>
                </div>
                
                <div class="insight-card">
                    <div class="insight-icon">üí∞</div>
                    <div class="insight-text">
                        Confident wrong predictions are costly
                    </div>
                </div>
            </div>
            
            <!-- Total Loss -->
            <div class="total-loss-box">
                Total Loss: Average over all training examples
            </div>
        </div>
        
        <!-- Visualization Section -->
        <div class="visualization-section">
            <div class="viz-title">üìä Interactive 3D Loss Surface</div>
            <div class="viz-subtitle">Drag to rotate ‚Ä¢ Scroll to zoom</div>
            
            <div id="canvas-container"></div>
            
            <div class="controls">
                <button class="control-btn" onclick="resetCamera()">üîÑ Reset View</button>
                <button class="control-btn" onclick="toggleWireframe()">üî≤ Toggle Wireframe</button>
                <button class="control-btn" onclick="toggleRotation()">‚öôÔ∏è Auto Rotate</button>
            </div>
            
            <div class="instruction">
                üí° Interact with the 3D surface: Click and drag to rotate, scroll to zoom in/out
            </div>
            
            <div class="viz-description">
                <strong>3D Surface Visualization:</strong> This interactive plot shows the Binary Cross-Entropy loss landscape with
                <span class="axis-label">X-axis: y (True Label, 0 or 1)</span>
                <span class="axis-label">Z-axis: ≈∑ (Predicted Value, 0-1)</span>
                <span class="axis-label">Y-axis: Loss (BCE)</span>
                <br><br>
                The surface is <strong>not convex</strong> in the traditional sense when visualized this way. 
                Note the two "valleys" at (0,0) and (1,1) where predictions match true labels.
                Colors: <strong style="color: #0066ff;">Blue (low loss)</strong> ‚Üí 
                <strong style="color: #ffff00;">Yellow</strong> ‚Üí 
                <strong style="color: #ff0000;">Red (high loss)</strong>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, surface;
        let isWireframe = false;
        let autoRotate = false;
        
        function init() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(10, 6, 10);
            camera.lookAt(0, 2, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight1.position.set(5, 10, 5);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);
            
            createLossSurface();
            createAxes();
            createGrid();
            
            addMouseControls();
            window.addEventListener('resize', onWindowResize);
            animate();
        }
        
        function createLossSurface() {
            const segments = 80;
            const size = 8;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            const positions = geometry.attributes.position.array;
            const colors = [];
            const color = new THREE.Color();
            const epsilon = 0.0001;
            
            // Calculate BCE loss for each point
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];      // This will be y (true label)
                const z = positions[i + 1];  // This will be ≈∑ (predicted)
                
                // Map from [-4, 4] to [0, 1]
                const yTrue = (x + size/2) / size;
                const yPred = (z + size/2) / size;
                
                // Clamp values to avoid log(0)
                const yTrueClipped = Math.max(epsilon, Math.min(1 - epsilon, yTrue));
                const yPredClipped = Math.max(epsilon, Math.min(1 - epsilon, yPred));
                
                // Calculate BCE loss: L = -[y*log(≈∑) + (1-y)*log(1-≈∑)]
                const loss = -(yTrueClipped * Math.log(yPredClipped) + 
                              (1 - yTrueClipped) * Math.log(1 - yPredClipped));
                
                // Set height (y-coordinate in 3D space)
                positions[i + 2] = loss;
                
                // Color based on loss value
                const normalizedLoss = Math.min(loss / 5, 1);
                
                if (normalizedLoss < 0.2) {
                    // Blue for low loss
                    const t = normalizedLoss * 5;
                    color.setRGB(0, t * 0.5, 1);
                } else if (normalizedLoss < 0.5) {
                    // Blue to cyan
                    const t = (normalizedLoss - 0.2) / 0.3;
                    color.setRGB(0, 0.5 + t * 0.5, 1 - t * 0.3);
                } else if (normalizedLoss < 0.7) {
                    // Cyan to yellow
                    const t = (normalizedLoss - 0.5) / 0.2;
                    color.setRGB(t, 1, 0.7 - t * 0.7);
                } else {
                    // Yellow to red
                    const t = (normalizedLoss - 0.7) / 0.3;
                    color.setRGB(1, 1 - t, 0);
                }
                
                colors.push(color.r, color.g, color.b);
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 60,
                specular: 0x333333,
                transparent: true,
                opacity: 0.4
            });
            
            surface = new THREE.Mesh(geometry, material);
            surface.rotation.x = -Math.PI / 2; // Rotate to make Z vertical
            scene.add(surface);
        }
        
        function createAxes() {
            const axisLength = 5;
            const axisRadius = 0.05;
            const arrowSize = 0.3;
            
            // X-axis (red) - True Label (y)
            const xAxisGeom = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 16);
            const xAxisMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const xAxis = new THREE.Mesh(xAxisGeom, xAxisMat);
            xAxis.position.set(0, 0, -4);
            xAxis.rotation.z = Math.PI / 2;
            scene.add(xAxis);
            
            const xArrow = new THREE.Mesh(
                new THREE.ConeGeometry(arrowSize, arrowSize * 2, 16),
                xAxisMat
            );
            xArrow.position.set(2.5, 0, -4);
            xArrow.rotation.z = -Math.PI / 2;
            scene.add(xArrow);
            
            // Y-axis (green) - Loss
            const yAxisGeom = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 16);
            const yAxisMat = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            const yAxis = new THREE.Mesh(yAxisGeom, yAxisMat);
            yAxis.position.set(-4, 2.5, -4);
            scene.add(yAxis);
            
            const yArrow = new THREE.Mesh(
                new THREE.ConeGeometry(arrowSize, arrowSize * 2, 16),
                yAxisMat
            );
            yArrow.position.set(-4, 5, -4);
            scene.add(yArrow);
            
            // Z-axis (blue) - Predicted (≈∑)
            const zAxisGeom = new THREE.CylinderGeometry(axisRadius, axisRadius, axisLength, 16);
            const zAxisMat = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            const zAxis = new THREE.Mesh(zAxisGeom, zAxisMat);
            zAxis.position.set(-4, 0, 0);
            zAxis.rotation.x = Math.PI / 2;
            scene.add(zAxis);
            
            const zArrow = new THREE.Mesh(
                new THREE.ConeGeometry(arrowSize, arrowSize * 2, 16),
                zAxisMat
            );
            zArrow.position.set(-4, 0, 2.5);
            zArrow.rotation.x = -Math.PI / 2;
            scene.add(zArrow);
            
            // Add larger, more visible text labels
            addTextLabel('y (True Label)', 4, -0.5, -4, 0xff0000, 1.5);
            addTextLabel('Loss (BCE)', -4.5, 6, -4, 0x00ff00, 1.5);
            addTextLabel('≈∑ (Predicted)', -4.5, -0.5, 4, 0x0000ff, 1.5);
            
            // Add value labels
            addTextLabel('0', -4.2, -0.3, -4, 0x666666, 0.8);
            addTextLabel('1', 4, -0.3, -4, 0x666666, 0.8);
            addTextLabel('0', -4.2, -0.3, -4, 0x666666, 0.8);
            addTextLabel('1', -4.2, -0.3, 4, 0x666666, 0.8);
        }
        
        function addTextLabel(text, x, y, z, color, scale = 1) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.font = 'Bold 60px Arial, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 256, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(2 * scale, 0.5 * scale, 1);
            
            scene.add(sprite);
        }
        
        function createGrid() {
            const gridSize = 8;
            const divisions = 8;
            
            // XZ plane grid at y=0
            const gridHelper = new THREE.GridHelper(gridSize, divisions, 0xcccccc, 0xe0e0e0);
            gridHelper.position.y = 0;
            scene.add(gridHelper);
        }
        
        function addMouseControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            const rotationSpeed = 0.005;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    const lookAt = new THREE.Vector3(0, 2, 0);
                    const distance = camera.position.distanceTo(lookAt);
                    
                    const theta = Math.atan2(camera.position.x - lookAt.x, camera.position.z - lookAt.z);
                    const phi = Math.acos((camera.position.y - lookAt.y) / distance);
                    
                    const newTheta = theta - deltaX * rotationSpeed;
                    const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + deltaY * rotationSpeed));
                    
                    camera.position.x = lookAt.x + distance * Math.sin(newPhi) * Math.sin(newTheta);
                    camera.position.y = lookAt.y + distance * Math.cos(newPhi);
                    camera.position.z = lookAt.z + distance * Math.sin(newPhi) * Math.cos(newTheta);
                    
                    camera.lookAt(lookAt);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const lookAt = new THREE.Vector3(0, 2, 0);
                const direction = camera.position.clone().sub(lookAt).normalize();
                const distance = camera.position.distanceTo(lookAt);
                const newDistance = Math.max(5, Math.min(25, distance + e.deltaY * 0.01));
                camera.position.copy(lookAt).add(direction.multiplyScalar(newDistance));
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate) {
                const lookAt = new THREE.Vector3(0, 2, 0);
                const radius = Math.sqrt(Math.pow(camera.position.x, 2) + Math.pow(camera.position.z, 2));
                const theta = Math.atan2(camera.position.x, camera.position.z) + 0.005;
                camera.position.x = radius * Math.sin(theta);
                camera.position.z = radius * Math.cos(theta);
                camera.lookAt(lookAt);
            }
            renderer.render(scene, camera);
        }
        
        function resetCamera() { 
            camera.position.set(10, 6, 10); 
            camera.lookAt(0, 2, 0); 
        }
        
        function toggleWireframe() { 
            isWireframe = !isWireframe; 
            surface.material.wireframe = isWireframe; 
        }
        
        function toggleRotation() { 
            autoRotate = !autoRotate; 
        }
        
        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        
        window.addEventListener('load', init);
    </script>
</body>
</html>